# AI 코딩 가이드라인

## 개요
이 문서는 AI가 코드를 작성하고 수정할 때 반드시 따라야 할 전제조건들을 정의합니다.
모든 변경사항은 기존 전제조건의 핵심 내용을 유지하면서 개선됩니다.

## 핵심 원칙

### 1. 파일 영향도 분석 및 검토
**목적**: 직접 수정한 파일뿐만 아니라 연관된 파일/모듈까지 영향도를 꼼꼼히 확인

**AI 실행 지침**:
- 코드 수정 전: 연관 모듈, 의존성, import, 네이밍 충돌 여부 확인
- 코드 수정 후: 빌드 오류, 테스트 실패, 런타임 오류 가능성 검토
- 예시: `CommonResponse` 수정 시 → `ErrorResponse`, `SwaggerResponseCustomizer` 등 연관 클래스 영향도 확인

**구체적 체크리스트**:
```
□ 수정 파일의 import 문 확인
□ 연관된 상수/열거형 클래스 영향도 확인  
□ 테스트 코드 동기화 필요성 검토
□ 빌드 설정 변경 필요성 확인
□ 문서 업데이트 필요성 검토
```

### 2. 보일러플레이트 목적 부합성 검증
**목적**: 멀티모듈 보일러플레이트의 목적(최소/공통/확장성/가독성)에 부합하는지 항상 체크

**AI 실행 지침**:
- **최소화**: 불필요한 코드, 과도한 의존성, 샘플/테스트 코드 최소화
- **공통화**: 공통 기능은 공통 모듈로 분리
- **확장성**: 새로운 모듈/기능 추가 시 기존 구조 유지
- **가독성**: 명확한 네이밍, 적절한 주석, 일관된 코드 스타일

**구체적 예시**:
```java
// ❌ 잘못된 예시 - 과도한 의존성
implementation 'com.example:heavy-library:1.0.0' // 사용하지 않는 라이브러리

// ✅ 올바른 예시 - 최소 의존성
implementation 'org.springframework.boot:spring-boot-starter-web' // 필요한 것만
```

### 3. 빌드 및 테스트 필수 실행
**목적**: 모든 변경 후 반드시 빌드와 테스트를 실행하여 정상 동작을 검증

**AI 실행 지침**:
- 코드 수정 후 즉시 `./gradlew build` 실행
- 테스트 실패 시 원인 분석 및 즉시 수정
- 빌드 성공 후 `./gradlew test` 실행
- 오류 발생 시 3회 이내 수정 시도

**구체적 실행 순서**:
```bash
1. ./gradlew clean
2. ./gradlew compileJava
3. ./gradlew test
4. ./gradlew build
```

### 4. 자동 문제 해결
**목적**: 사용자가 명시적으로 "수정하지 마세요" 또는 "분석만 해주세요"라고 요청하지 않는 한, 모든 문제를 자동으로 해결

**AI 실행 지침**:
- 컴파일 오류 발견 시 즉시 수정
- 테스트 실패 시 원인 분석 후 수정
- 하드코딩 발견 시 상수화/설정 분리
- 네이밍 문제 발견 시 즉시 개선

**구체적 예시**:
```
발견된 문제: "cannot find symbol: SUCCESS_CODE"
AI 자동 수정: HttpStatusConstants.SUCCESS_CODE로 변경
```

### 5. 네이밍 검토 및 개선
**목적**: 파일명, 클래스명, 변수명이 목적과 기능에 적절한지 검토하고, 부적절한 경우 즉시 개선

**AI 실행 지침**:
- 클래스명: 명사형, 기능을 명확히 표현
- 메서드명: 동사형, 동작을 명확히 표현
- 변수명: 의미를 명확히 전달
- 상수명: 대문자, 언더스코어 구분

**구체적 네이밍 규칙**:
```java
// ❌ 잘못된 예시
class Data {} // 너무 일반적
void process() {} // 무엇을 처리하는지 불명확
String s; // 의미 불명확

// ✅ 올바른 예시  
class UserService {} // 명확한 기능
void validateUserInput() {} // 명확한 동작
String userEmail; // 명확한 의미
```

### 6. 하드코딩 검토 및 개선
**목적**: 하드코딩된 값이 부적절한 경우 즉시 개선 (설정 파일로 분리, 상수화, 외부화 등)

**AI 실행 지침**:
- 매직 넘버/문자열 발견 시 상수 클래스로 분리
- 설정값은 application.properties/yml로 분리
- 환경별 설정은 profile로 분리

**구체적 예시**:
```java
// ❌ 잘못된 예시
if (status == 200) { ... }
String mediaType = "application/json";

// ✅ 올바른 예시
if (status == HttpStatusConstants.OK) { ... }
String mediaType = HttpStatusConstants.APPLICATION_JSON;
```

### 7. 테스트 코드 구조화
**목적**: 테스트 코드는 통합, 단위, mock 테스트를 진행하고 각각 파일별로 만든다

**AI 실행 지침**:
- **단위 테스트**: `ClassNameTest.java` - 개별 메서드/클래스 테스트
- **통합 테스트**: `ClassNameIntegrationTest.java` - 스프링 컨텍스트 로드 테스트
- **Mock 테스트**: `ClassNameMockTest.java` - 외부 의존성 모킹 테스트

**구체적 파일 구조 예시**:
```
src/test/java/com/hjm/api/
├── UserServiceTest.java           # 단위 테스트
├── UserServiceIntegrationTest.java # 통합 테스트  
├── UserServiceMockTest.java       # Mock 테스트
└── UserControllerTest.java        # 컨트롤러 테스트
```

**테스트 커버리지 목표**:
- 단위 테스트: 80% 이상
- 통합 테스트: 주요 시나리오 커버
- Mock 테스트: 외부 의존성 100% 커버

### 8. 가이드라인 자동 업데이트
**목적**: 전제조건 업데이트 사항이나 추가항이 있는 경우 해당 파일에도 반영

**AI 실행 지침**:
- 새로운 코딩 규칙 발견 시 이 파일에 추가
- 기존 규칙 개선 시 즉시 반영
- 예시 코드 업데이트 시 함께 수정

### 9. 가독성 개선
**목적**: 해당 파일이 가독성이 불편한 경우 레이아웃을 변경

**AI 실행 지침**:
- 적절한 공백과 들여쓰기 적용
- 메서드/클래스 간 구분선 추가
- 주석 스타일 통일
- import 문 정리

**구체적 가독성 규칙**:
```java
// 클래스 시작
public class ExampleClass {
    
    // 상수 영역
    private static final String CONSTANT = "value";
    
    // 필드 영역
    private String field;
    
    // 생성자
    public ExampleClass() {
        // 생성자 로직
    }
    
    // 메서드 영역
    public void method() {
        // 메서드 로직
    }
}
```

## AI 실행 우선순위

1. **즉시 실행**: 컴파일 오류, 빌드 실패
2. **높은 우선순위**: 테스트 실패, 하드코딩 발견
3. **중간 우선순위**: 네이밍 개선, 가독성 향상
4. **낮은 우선순위**: 문서 업데이트, 예시 추가

## AI 실행 체크리스트

### 코드 수정 전
- [ ] 연관 파일 영향도 분석
- [ ] 보일러플레이트 목적 부합성 확인
- [ ] 기존 테스트 코드 검토
- [ ] **기술/아키텍처가 트렌디하며 레거시가 아닌지 확인**
    - 최신 프레임워크, 모듈 구조, 표준 라이브러리 사용 여부
    - 더 이상 권장되지 않는 패턴/구조/라이브러리 사용 금지
- [ ] **테스트 용이성(테스트 친화적 코드) 확인**
    - 의존성 주입, Mocking 용이성, 단위/통합 테스트 작성 가능 구조
    - 테스트 커버리지 확보가 어려운 구조/코드 지양

### 코드 수정 중
- [ ] 네이밍 규칙 준수
- [ ] 하드코딩 제거
- [ ] 가독성 개선

### 코드 수정 후
- [ ] 빌드 실행 및 성공 확인
- [ ] 테스트 실행 및 성공 확인
- [ ] 연관 파일 동기화
- [ ] 문서 업데이트

## 예시 시나리오

### 시나리오 1: 새로운 API 응답 클래스 추가
```
1. CommonResponse 클래스 수정
2. 연관된 ErrorResponse, SwaggerResponseCustomizer 확인
3. 테스트 코드 추가 (단위/통합/Mock)
4. 하드코딩 값 상수화
5. 빌드 및 테스트 실행
6. 가이드라인 업데이트 (필요시)
```

### 시나리오 2: 에러 코드 추가
```
1. ErrorCodeEnum에 새 코드 추가
2. HttpStatusConstants에 관련 상수 추가
3. ErrorResponse 테스트 업데이트
4. 관련 문서 업데이트
5. 빌드 및 테스트 실행
```

### 시나리오 3: 레거시 코드/비표준 구조 개선
```
1. 레거시 패턴(예: XML 기반 DI, 오래된 라이브러리) 발견 시 최신 표준(Spring Boot, Java Config 등)으로 개선
2. 테스트가 어려운 구조(정적 메서드, 강한 결합 등) 발견 시 DI, 인터페이스 분리 등으로 리팩토링
3. 빌드 및 테스트 실행
4. 가이드라인 업데이트(필요시)
```

## 주의사항

- **변경 불가능한 전제조건**: 레이아웃 변경, 전제조건 추가는 기존 전제조건의 핵심내용들은 변경하지 않는다
- **자동화 원칙**: 사용자가 명시적으로 금지하지 않는 한 모든 문제를 자동으로 해결
- **품질 우선**: 코드 품질과 가독성을 최우선으로 고려

---

**이 가이드라인은 지속적으로 개선되며, 새로운 규칙이나 예시가 발견되면 즉시 추가됩니다.**